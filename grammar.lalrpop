use ::std::str::FromStr;

use crate::load::ast::*;
use ::lalrpop_util as __lalrpop_util;

grammar;

match {
    // Turn newlines into a token (they are skipped by default)
    r"(\r\n|\n|\r)(\s|\r|\n)*" => END,
} else {
    // Ignore any other whitespace
    r"\s+" => { },
} else {
    _
}

pub evolution: EvolutionAst = {
    END? <ds:(<dependency>)*> <es:(<block>)*> END => EvolutionAst::new(ds, es),
};

dependency: Dependency = {
    "depends on" <name:path> "~" END => Dependency::dynamic(name),
    "depends on" <name:path> <hash:"'[a-zA-Z0-9]+'"> END => Dependency::fixed(name, hash),
};

block: Block = {
    "add" "object" <name:identifier> "{" END <fields:(<object_field>)*> "}" => Block::new(name, fields),
};

object_field: ObjectField = {
    <name:identifier> ":" <typ:identifier> END => ObjectField::new(name, typ),
}

identifier: Iden = {
    <n:r"[a-zA-Z_][a-zA-Z0-9_]*"> => Iden::new(n.to_owned()),
};

path: Path = {
    <n:r"'[a-zA-Z_][a-zA-Z0-9_]*(/[a-zA-Z_][a-zA-Z0-9_]*)*'(.apiv)?"> => Path::new(n.to_owned()),
    <n:"\"[a-zA-Z_][a-zA-Z0-9_]*(/[a-zA-Z_][a-zA-Z0-9_]*)*\"(.apiv)?"> => Path::new(n.to_owned()),
};
