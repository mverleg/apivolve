use ::std::str::FromStr;

use crate::load::ast::*;

grammar;

match {
    // Turn newlines into a token (they are skipped by default)
    r"(\r\n|\n|\r)(\s|\r|\n)*" => END,
} else {
    // Match string literals
    r#"("[^"]*"|([^"]*\\")*)"# => STR,
} else {
    // Ignore comments (only full-line for now)
    r#"\s*#[^\r\n]*(\r\n|\n|\r)(\s|\r|\n)*"# => { },
} else {
    // Ignore any other whitespace (except newlines above)
    r"\s+" => { },
} else {
    _
}

pub evolution: EvolutionAst = {
    END? <ds:(<dependency>)*> <es:(<block>)*> END => EvolutionAst::new(ds, es),
};

dependency: Dependency = {
    "depends on" <p:STR> "dynamic" END => Dependency::dynamic(Path::new(p)),
//    "depends on" <p:path> "hash" <hash:"'[a-zA-Z0-9]+'"> END => Dependency::fixed(p, hash),
    "depends on" <p:STR> "hash" <hash:STR> END => Dependency::fixed(Path::new(p), hash),
};

object_field: ObjectField = {
    "add" <name:identifier> "type" <typ:identifier> "default" <def:value> END => ObjectField::add(name, typ),
    "add" <name:identifier> "type" <typ:identifier> END => ObjectField::add(name, typ),
}

block: Block = {
    "add" "object" <name:identifier> "{" END <fields:(<object_field>)*> "}" => Block::AddObj(AddObject::new(name, fields)),
    "change" "object" <name:identifier> "{" END <fields:(<object_field>)*> "}" => Block::ChangeObj(ChangeObject::new(name, fields)),
};

identifier: Iden = {
    <l: @L> <n:r"[a-zA-Z_][a-zA-Z0-9_]*"> <r: @R> => Iden::new(n.to_owned(), l, r),
};

//TODO @mark: support more types
value: Value = {
    <l: @L> <v:STR> <r: @R> => Value::Str(v.to_owned(), span(l, r)),
}